<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Result.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Result</a> &gt; <a href="index.source.html" class="el_package">result</a> &gt; <span class="el_source">Result.java</span></div><h1>Result.java</h1><pre class="source lang-java linenums">package result;

import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * A result type containing either a value of type T or an error.
 *
 * @param &lt;T&gt; The type of the value.
 *
 * @author Alan Teesdale
 */
public sealed interface Result&lt;T, E&gt; permits Err, Ok {

    /**
     * Convert a method into a result.
     *
     * @param function The function to run.
     * @param &lt;T&gt; The return type of the function.
     *
     * @return Convert the result of a function that could throw into a result.
     *     Which contains either the value or the error.
     *     (Immediately runs the provided function)
     */
    static &lt;T&gt; Result&lt;T, Throwable&gt; fromFunction(FallibleSupplier&lt;T&gt; function) {
<span class="fc" id="L31">        Objects.requireNonNull(function);</span>
        try {
<span class="fc" id="L33">            return Result.ok(function.get());</span>
<span class="fc" id="L34">        } catch (Throwable e) {</span>
<span class="fc" id="L35">            return Result.err(e);</span>
        }
    }

    /**
     * Convert the runnable into a result.
     *
     * @param runnable The runnable that gets converted into a result.
     * @return Convert the result of the runnable to the empty result, or an error if one occurred.
     */
    static Result&lt;Void, Throwable&gt; fromFunction(FallibleRunnable runnable) {
<span class="fc" id="L46">        Objects.requireNonNull(runnable);</span>
        try {
<span class="fc" id="L48">            runnable.run();</span>
            // needed to bypass the null checks from result.of
<span class="fc" id="L50">            return new Ok&lt;&gt;(null);</span>
<span class="fc" id="L51">        } catch (Throwable e) {</span>
<span class="fc" id="L52">            return Result.err(e);</span>
        }
    }

    /**
     * Create an Ok result holding the value.
     *
     * @param value The value the result should hold.
     * @param &lt;T&gt;   The type of the value.
     * @return the ok result with a given value.
     */
    static &lt;T, E&gt; Result&lt;T, E&gt; ok(T value) {
<span class="fc" id="L64">        return new Ok&lt;&gt;(Objects.requireNonNull(value));</span>
    }

    /**
     * Create an error variant of the result.
     *
     * @param error A supplier of an error - the invalid result.
     * @param &lt;T&gt; The type of the result.
     * @return The error result with a given supplier.
     */
    static &lt;T, E&gt; Result&lt;T, E&gt; err(E error) {
<span class="fc" id="L75">        return new Err&lt;T, E&gt;(Objects.requireNonNull(error));</span>
    }

    /**
     * Get the value out of the result, throws the error of the result if of the Err variant.
     * Wraps the Error in a runtime exception.
     *
     * @return The value if it exists or,
     *
     * @throws RuntimeException if the value doesn't exist.
     */
    T get() throws RuntimeException;

    /**
     * Get the Error if of the Err variant.
     *
     * @return The error that this result holds
     *
     * @throws NoSuchElementException if the result has no error - if it is the Ok variant.
     */
	 E getError() throws NoSuchElementException;

    /**
     * Returns if the result is of the Ok var.
     *
     * @return true if the result is okay, that is if it is not the err variant.
     */
    boolean isOk();


    /**
     * Returns if the result is of the Err variant.
     *
     * @return true if the result is **not** okay, that is if it is the err variant.
     */
    default boolean hasError() {
<span class="fc bfc" id="L111" title="All 2 branches covered.">        return !isOk();</span>
    }

    /**
     * Run a consumer on the value if the result is okay.
     *
     * @param action the action to run on the result
     */
    void ifOk(Consumer&lt;? super T&gt; action);

    /**
     * Run a consumer on the value if the result is okay, otherwise run the empty action.
     *
     * @param action      the action to run on the result
     * @param emptyAction the thing to run if there is no result
     */
    void ifOkOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction);


    /**
     * Use the mapper to map the value to a different value.
     * Keeps the error if the result is of error type.
     *
     * @param mapper map the value of the result to a different one if it exists
     * @param &lt;U&gt;    the type to map to
     * @return A result containing the mapped value.
     */
    &lt;U&gt; Result&lt;U, E&gt; map(Function&lt;? super T, ? extends U&gt; mapper);


    /**
     * Works similarly to map, but flattens the result down, keeps the current error if one exists.
     *
     * @param mapper the function that maps the value to the new result
     * @param &lt;U&gt;    The new type of the result
     * @return a new result provided by the mapper given the value of this result
     */
    &lt;U&gt; Result&lt;U, E&gt; flatMap(Function&lt;? super T, ? extends Result&lt;? extends U, ? extends E&gt;&gt; mapper);

    /**
     * map the Error to a different Error type.
     *
     * @param mapper A function that takes the error to a different error type.
     *
     * @return A result which has the Err variant mapped to a different error.
     */
    &lt;U&gt; Result&lt;T, U&gt; mapError(Function&lt;? super E, ? extends U&gt; mapper);

    /**
     * flatMap the error variant a value
     *
     * @param mapper The error mapping function.

     * @return A result of Ok(T) if the result is Ok or the mapper returns Ok(T)
     */
	 &lt;U&gt; Result&lt;T, U&gt; flatMapError(Function&lt;? super E, Result&lt;? extends T, ? extends U&gt;&gt; mapper);

	/**
     * Map the error variant of a particular error to a value
     *
     * @param shouldMap Map the error if it matches the predicate
     * @param mapper The error mapping function (Err(E) -&gt; Ok(T))

     * @return A result which is unchanged unless it's an Err where the error is an instance of E.
     */
	 Result&lt;T, E&gt; transformMatchingError(Predicate&lt;? super E&gt; shouldMap, Function&lt;? super E, ? extends T&gt; mapper);

    /**
     * flatMap the error matching the predicate.
     * @param shouldMap Whether to map the error or not.
     * @param mapper The mapper.

     * @return The flatMapped error
     */
    Result&lt;T, E&gt; flatMapMatchingError(Predicate&lt;? super E&gt; shouldMap, Function&lt;E, Result&lt;? super T, ? extends E&gt;&gt; mapper);

    /**
     * Returns the result from the supplier if this is the Err variant, otherwise returns itself.
     *
     * @param supplier A supplier of a result, which gets run if this is of the Err variant.
     *
     * @return This result if it's Ok, otherwise the result given by the supplier.
     */
    Result&lt;T, E&gt; or(Supplier&lt;? extends Result&lt;? extends T, ? extends E&gt;&gt; supplier);


    /**
     * Convert this result into an optional.
     *
     * @return An optional which holds the value if it exists.
     */
    Optional&lt;T&gt; toOptional();

    /**
     * Gets the value from the result if it exists, otherwise returns the other value.
     *
     * @param other the value to return if the result is of the Err variant.
     *
     * @return either the value of the result if it exists or the other value.
     */
    T orElse(T other);


    /**
     * A match style statement for the result type, to allow matching over multiple errors.
     *
     * @param defaultArm   The catchall arm
	 * @param matchArms    The MatchArms, can be {@link OkArm} or {@link ErrArm}
     * @param &lt;U&gt;          the return type
     *
     * @return a U given by the match arms
     */
    &lt;U&gt; U match(
			Function&lt;Result&lt;T, E&gt;, U&gt; defaultArm,
            @SuppressWarnings(&quot;unchecked&quot;) MatchArm&lt;T, E, U&gt;... matchArms
    );
	
	/**
     * A match style statement for the result type, to allow matching over multiple errors.
     *
     * @param defaultOk    The catchall ok match arm
	 * @param defaultErr   The catchall err match arm
	 * @param matchArms    The MatchArms, can be {@link OkArm} or {@link ErrArm}
     * @param &lt;U&gt;          the return type
     *
     * @return a U given by the match arms
     */
    @SuppressWarnings({&quot;varargs&quot;, &quot;unchecked&quot;})
    &lt;U&gt; U match(
			Function&lt;T, U&gt; defaultOk,
			Function&lt;E, U&gt; defaultErr,
            MatchArm&lt;T, E, U&gt;... matchArms
    );

    /**
     * Gets the value from the result if it exists, otherwise returns the result of the supplier.
     *
     * @param supplier the supplier to run if the result is of the Err variant.
     *
     * @return either the value of the result if it exists or the result of the supplier.
     */
    T orElseGet(Function&lt;? super E, ? extends T&gt; supplier);

    /**
     * Make an Ok an error variant if it doesn't match the filter.
     *
     * @param predicate The predicate the value must match.
     * @param toError A Function of an error for the Err case if it doesn't match the predicate.
     *
     * @return A result of Err variant if the value doesn't match the predicate.
     */
    Result&lt;T, E&gt; filter(Predicate&lt;? super T&gt; predicate, Function&lt;? super T, ? super E&gt; toError);

    /**
     * Throw a custom error if the result is of Err type, otherwise get the value.
     *
     * @param newError a supplier of the new error to throw if of the Err variant.
     *
     * @return The value of the Ok variant.
     */
    &lt;Er extends Throwable&gt; T orElseThrow(Supplier&lt;? extends Er&gt; newError) throws Er;

    /**
     * Throw a custom error if the result is of Err type, otherwise get the value.
     *
     * @param newError a function that converts the stored error to a new error,
     *                 while maintaining the stack trace.
     *
     * @return the value of the Ok variant.
     */
    &lt;Er extends Throwable&gt; T orElseThrow(Function&lt;E, Er&gt; newError) throws Er;

}


</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>